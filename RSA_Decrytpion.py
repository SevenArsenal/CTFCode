
# RSA暗号とは？仕組みや応用事例を初心者にもわかりやすく解説！
# RSA暗号とは、素因数分解の難しさを利用した暗号アルゴリズムのことです。セキュリティ対策を考える中で、暗号化の仕組みが気になっている人は多いでしょう。

# 素因数分解が困難であることを利用したアルゴリズム
# 大きな数字を素因数分解するのは困難です。総当たりする以外に素因数を見つけ出す方法がないためです。したがって、コンピュータで素因数分解しようとしても、大きな数であれば膨大な時間がかかります。

# この仕組みを利用した暗号がRSA暗号です。RSAは発明した３人の名前「R. L. Rivest、A. Shamir、L. Adleman」に由来します。

# 素因数分解の難しさを安全性の根拠にするということは、逆に言えば素因数分解されてしまうと解読されるということです。膨大な時間を掛けてコンピュータで計算すれば素因数分解されてしまいます。

# しかし、それまでには情報の価値が失われているため、暗号として機能するのです。

# 公開鍵暗号方式のアルゴリズムの一種
# 公開鍵暗号方式とは、暗号鍵と復号鍵が別々の暗号方式です。データを解読するために使うのは復号鍵であって、暗号鍵ではありません。

# つまり、暗号鍵は第三者に見られても問題ないということです。暗号鍵は第三者を含め誰にでも公開されて使われることから、公開鍵暗号方式と呼ばれます。

# 公開鍵暗号方式で使われる暗号アルゴリズムの種類はさまざまです。たとえば、DH法は鍵を交換するためのアルゴリズムです。暗号化のアルゴリズムではないため、暗号化にはほかのアルゴリズムを使う必要があります。

# RSA暗号も公開鍵暗号方式で使われるアルゴリズムの一種ですが、鍵の交換だけでなく暗号化とデジタル署名を実現するアルゴリズムです。暗号とデジタル署名を両方とも達成できるアルゴリズムとして、世界で初めて登場しました。


# １．受信者が公開鍵と秘密鍵を生成する
# 始めに、データを受信する側が公開鍵と秘密鍵を準備しなければなりません。以下の手順で鍵を生成します。

# １．異なる２つの大きな素数「p」「q」を任意にとる
# ２．n＝pqとする
# ３．（p-１）（q-１）と互いに素な自然数eを任意にとる
# ４．edを（p-１）（q-１）で割った余りが１となる自然数dを任意にとる		???????? 仕様が違うらしい！！！！！！！！！！！！！！！！！！！！
# 「互いに素」とは、最大公約数が１という意味です。こうして用意したnとeを公開鍵としてメッセージ送信側に渡します。p・q・dは秘密鍵であるため公開しません。では、上の手順の具体例を見ていきましょう。

# １．p＝７、q＝５とする
# ２．n＝７×５＝35
# ３．（p-１）（q-１）＝６×４＝24なため、e＝５とする
# ４．d＝５とする。このとき、ed÷（p-１）（q-１）＝１余り１となる
# ２．送信者がメッセージを暗号化する


# --------------------------------------------sender ------------------------------------------------------------
# 次は、メッセージの送信側が作業します。受信側から受け取った公開鍵であるnとeを使い、以下の手順でメッセージを暗号化しましょう。

# １．送りたいメッセージを自然数xとする。ただしx＜nとする
# ２．xをe乗し、これをnで割った余りをyとする
# こうして算出されたyが暗号文です。これを受信側に送信します。では、上の手順の具体例を見ていきましょう。
# ---------------------------------------------------------------------------------------------------------------

# １．x＝12とする。これはx＜nを満たす（n＝35）
# ２．12を５乗し、これを35で割ると余りy＝17となる
# ３．受信者がメッセージを復号する
# 最後に、受信側は送られてきた暗号文yを復号し、平文を得ます。解き方の手順は以下のとおりです。

#---------------------------------------------revicer -------------------------------------------------------------
# １．yをd乗する
# ２．これをnで割った余りが平文xとなる
# では、上の手順の具体例を見ていきましょう。
#------------------------------------------------------------------------------------------------------------------

# １．17を５乗する
# ２．これを35で割った余りが平文12となる
# 復号するにはdが必要ですが、これは受信者しか持たない秘密鍵であるため、第三者には復号されません。


# prime_num_A :P
# prime_num_B :q 
# N -> N = prime_num_A*prime_num_B
# e -> (prime_num_A-1)*(prime_num_B-1)⊥e  ( ⊥ ：互いに素)
# d => e*d Mod((prime_num_A-1)*(prime_num_B-1)) = 1

# Revicer --------------- > Sender (e,N)
# Sedner use (e,N) do Encryption Message: Message **e Mod(N) = Ecp	&& Message < N
# Sender ----------------->Revicer Encrypted message
# Sender use (e,N) do Decryption Ecp: Ecp **d Mod(N) = Message 
from decimal import Decimal
import math
from operator import truediv
from unicodedata import decimal

message = 0
e = 11
N = 236934049743116267137999082243372631809789567482083918717832642810097363305512293474568071369055296264199854438630820352634325357252399203160052660683745421710174826323192475870497319105418435646820494864987787286941817224659073497212768480618387152477878449603008187097148599534206055318807657902493850180695091646575878916531742076951110529004783428260456713315007812112632429296257313525506207087475539303737022587194108436132757979273391594299137176227924904126161234005321583720836733205639052615538054399452669637400105028428545751844036229657412844469034970807562336527158965779903175305550570647732255961850364080642984562893392375273054434538280546913977098212083374336482279710348958536764229803743404325258229707314844255917497531735251105389366176228741806064378293682890877558325834873371615135474627913981994123692172918524625407966731238257519603614744577

encryptioned = 80265690974140286785447882525076768851800986505783169077080797677035805215248640465159446426193422263912423067392651719120282968933314718780685629466284745121303594495759721471318134122366715904
decryptioned = 0

max = N
min = 1
times = 0


flag = 1
while flag == 1:
	temp = N*times+encryptioned 
	while min**11 <temp and min != (min+max)//2:
		min = (min+max)//2
	
	min = 2*min - max
	print("min=",min)
	while max**11 >temp and max != (min+max)//2:
		max = (min+max)//2
	max = 2*max-min;
	print("max=",max)
	print("max-min=",max-min)
	
	if max-min <=4:
		for index in range (min-min%2,max+max%2):
			if  N*times+encryptioned == index**11:
				flag = 0
				decryptioned = index
				print("index=",decryptioned)
				break

		print("times=",times)
		print("min**11-temp =",min**11-temp)
		print("max**11-temp =",max**11-temp )
		times+=1
		min =0
		max = N
print("M=",decryptioned)	
print("Message**11(mod N)-Ecp=",decryptioned**11%N-encryptioned)
	

for index in range (1,1000000000):
	if (encryptioned**index)%N == decryptioned:
		print('d=',index)
		break;
 
    
				
		
		
